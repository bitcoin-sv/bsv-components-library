package com.nchain.jcl.net.unit.protocol.serialization

import com.nchain.jcl.net.protocol.config.ProtocolConfigBuilder
import com.nchain.jcl.net.protocol.serialization.common.BitcoinMsgSerializer
import com.nchain.jcl.net.protocol.serialization.common.BitcoinMsgSerializerImpl
import com.nchain.jcl.net.protocol.serialization.common.DeserializerContext
import com.nchain.jcl.net.protocol.config.ProtocolConfig
import com.nchain.jcl.net.protocol.config.provided.ProtocolBSVMainConfig
import com.nchain.jcl.net.protocol.messages.VersionAckMsg
import com.nchain.jcl.net.protocol.messages.common.BitcoinMsg
import com.nchain.jcl.net.protocol.messages.common.BitcoinMsgBuilder
import com.nchain.jcl.net.protocol.serialization.common.SerializerContext
import com.nchain.jcl.net.unit.protocol.tools.ByteArrayArtificalStreamProducer
import com.nchain.jcl.tools.bytes.ByteArrayReader
import io.bitcoinj.core.Utils
import io.bitcoinj.params.MainNetParams
import io.bitcoinj.params.Net
import spock.lang.Specification

/**
 * Testing class for the VerAckMsg Serialization.
 * The test is taken the assumption that we have already a correct serialization version of this Message, obtained
 * from another source that we trust (in this case the Java BitcoinJ library). So we serialize/deserialize some
 * messages with out code and compare the results with that reference.
 */
class VerackSerializationSpec extends Specification {

    // This is a VERACK Message Serialized for the Main Network in HEX format, generated by a third party (bitcoinJ)
    public static final String VERACK_MSG = "e3e1f3e876657261636b000000000000000000005df6e0e2"

    def "Testing Verack Full Message Deserializing"(int byteInterval, int delayMs) {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            DeserializerContext context = DeserializerContext.builder()
                        .protocolBasicConfig(config.getBasicConfig())
                        .build()
            BitcoinMsgSerializer bitcoinSerializer = BitcoinMsgSerializerImpl.getInstance()
                BitcoinMsg<VersionAckMsg> version = null
            ByteArrayReader byteReader = ByteArrayArtificalStreamProducer.stream(Utils.HEX.decode(VERACK_MSG), byteInterval, delayMs)
        when:
            version = bitcoinSerializer.<VersionAckMsg>deserialize(context, byteReader, VersionAckMsg.MESSAGE_TYPE)
        then:
            version.getHeader().getCommand().equals(VersionAckMsg.MESSAGE_TYPE)
            version.getHeader().getMagic() == config.getBasicConfig().getMagicPackage()
        where:
            byteInterval | delayMs
                10       |    15
    }

    def "Testing Verack Full Message Serialization"() {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            SerializerContext context = SerializerContext.builder()
                    .protocolBasicConfig(config.getBasicConfig())
                    .build()
            BitcoinMsg<VersionAckMsg> versionAck = new BitcoinMsgBuilder<>(config.getBasicConfig(), VersionAckMsg.builder().build()).build()
            BitcoinMsgSerializer bitcoinSerializer = BitcoinMsgSerializerImpl.getInstance()
            String msgSerializedHex = null
        when:
            byte[] serializedMsg = bitcoinSerializer.serialize(context, versionAck, VersionAckMsg.MESSAGE_TYPE).getFullContent()
            msgSerializedHex = Utils.HEX.encode(serializedMsg)
        then:
            msgSerializedHex.equals(VERACK_MSG)
    }
}
