package io.bitcoinsv.jcl.net.unit.protocol.serialization

import io.bitcoinsv.jcl.net.network.PeerAddress
import io.bitcoinsv.jcl.net.protocol.config.ProtocolConfig
import io.bitcoinsv.jcl.net.protocol.config.ProtocolConfigBuilder
import io.bitcoinsv.jcl.net.protocol.messages.NetAddressMsg
import io.bitcoinsv.jcl.net.protocol.serialization.NetAddressMsgSerializer
import io.bitcoinsv.jcl.net.protocol.serialization.common.DeserializerContext
import io.bitcoinsv.jcl.net.protocol.serialization.common.SerializerContext
import io.bitcoinsv.jcl.net.unit.protocol.tools.ByteArrayArtificalStreamProducer
import io.bitcoinsv.jcl.tools.bytes.ByteArrayReader
import io.bitcoinsv.jcl.tools.bytes.ByteArrayWriter
import io.bitcoinsv.bitcoinjsv.core.Utils
import io.bitcoinsv.bitcoinjsv.params.MainNetParams
import io.bitcoinsv.bitcoinjsv.params.Net
import spock.lang.Specification

/**
 * Testing class for the NetAddressMsg Message Serialization.
 * The test is taken the assumption that we have already a correct serialization version of this Message, obtained
 * from another source that we trust (in this case the Java BitcoinJ library). So we serialize/deserialize some
 * messages with out code and compare the results with that reference.
 */
class NetAddressSerializationSpec extends Specification {

    // This is a NetAddressMsg Message Serialized for the Main Network in HEX format,
    // generated by a third party (bitcoinJ).
    // The following Serialized value for an Address has been produced using:
    // - Main Network
    // - timestamp: 0
    // - Localhost and standard getPort (8333)

    private static final String REF_ADDRESS_MSG = "0b6d2f5d000000000000000000000000000000000000ffff7f000001208d"
    private static final long REF_TIMESTAMP = 1563389195
    private static final int REF_PORT = 8333
    private static final PeerAddress REF_ADDRESS = new PeerAddress(InetAddress.getByName("localhost"), REF_PORT)

    def "Testing NetAddress Deserializing"(int byteInterval, int delayMs) {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            DeserializerContext context = DeserializerContext.builder()
                    .protocolBasicConfig(config.getBasicConfig())
                    .build()
            NetAddressMsgSerializer serializer = NetAddressMsgSerializer.getInstance()
            NetAddressMsg address = null
            ByteArrayReader byteArrayReader = ByteArrayArtificalStreamProducer.stream(Utils.HEX.decode(REF_ADDRESS_MSG), byteInterval, delayMs);
        when:
            address = serializer.deserialize(context, byteArrayReader)
        then:
            address.getLengthInBytes() == NetAddressMsg.MESSAGE_LENGTH
            address.getAddress().getIp().getCanonicalHostName().equals(REF_ADDRESS.getIp().getCanonicalHostName())
            address.getAddress().getPort() == config.getBasicConfig().getPort()
        where:
            byteInterval | delayMs
                10       |    15
    }

    def "Testing NetAddress Serializing"() {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            SerializerContext context = SerializerContext.builder()
                    .protocolBasicConfig(config.getBasicConfig())
                    .build()
            NetAddressMsgSerializer serializer = NetAddressMsgSerializer.getInstance()

            NetAddressMsg address = NetAddressMsg.builder()
                    .timestamp(REF_TIMESTAMP)
                    .address(new PeerAddress(InetAddress.getByName("localhost"), config.getBasicConfig().getPort()))
                    .build()
            String msgSerializedHex = null
        when:
            ByteArrayWriter byteWriter = new ByteArrayWriter()
            serializer.serialize(context, address, byteWriter)
            byte[] addressBytes = byteWriter.reader().getFullContent()
            msgSerializedHex = Utils.HEX.encode(addressBytes)
        then:
            msgSerializedHex.equals(REF_ADDRESS_MSG)
    }
}
