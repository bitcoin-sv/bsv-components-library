package io.bitcoinsv.bsvcl.net.protocol.serialization

import io.bitcoinsv.bitcoinjsv.core.Sha256Hash
import io.bitcoinsv.bsvcl.net.protocol.config.ProtocolConfig
import io.bitcoinsv.bsvcl.net.protocol.config.ProtocolConfigBuilder
import io.bitcoinsv.bsvcl.net.protocol.messages.RejectMsg
import io.bitcoinsv.bsvcl.net.protocol.messages.VarStrMsg
import io.bitcoinsv.bsvcl.net.protocol.messages.common.BitcoinMsg
import io.bitcoinsv.bsvcl.net.protocol.messages.common.BitcoinMsgBuilder
import io.bitcoinsv.bsvcl.net.protocol.serialization.common.BitcoinMsgSerializer
import io.bitcoinsv.bsvcl.net.protocol.serialization.common.BitcoinMsgSerializerImpl
import io.bitcoinsv.bsvcl.net.protocol.serialization.common.DeserializerContext
import io.bitcoinsv.bsvcl.net.protocol.serialization.common.SerializerContext
import io.bitcoinsv.bsvcl.net.protocol.tools.ByteArrayArtificalStreamProducer
import io.bitcoinsv.bsvcl.common.bytes.ByteArrayReader
import io.bitcoinsv.bsvcl.common.bytes.ByteArrayWriter
import io.bitcoinsv.bitcoinjsv.core.Utils
import io.bitcoinsv.bitcoinjsv.params.MainNetParams
import io.bitcoinsv.bitcoinjsv.params.Net
import spock.lang.Specification

/**
 * Testing class for the RejectMsg Message Serialization.
 * The test is taken the assumption that we have already a correct serialization version of this Message, obtained
 * from another source that we trust (in this case the Java BitcoinJ library). So we serialize/deserialize some
 * messages with out code and compare the results with that reference.
 */
class RejectMsgSerializationSpec extends Specification {

    // This is the REJECT MSG used as a reference, to compare to our own Serialization.
    // This message has been generated by bitcoinJ using the following values:
    // - Main network
    // - message: "Testing"
    // - ccode: INVALID
    // - reason: "Dummy Reason"
    // - data: empty (null)

    private static final String REF_REJECT_MSG = "e3e1f3e872656a6563740000000000003600000006fdf977" + REF_REJECT_BODY_MSG;
    private static final String REF_REJECT_BODY_MSG = "0754657374696e67100c44756d6d7920526561736f6e" + REF_REJECT_BODY_HASH
    private static final String REF_REJECT_BODY_HASH = "0000000000000000000000000000000000000000000000000000000000000000";
    private static final String REF_MESSAGE = "Testing"
    private static final RejectMsg.RejectCode REF_CCODE = RejectMsg.RejectCode.INVALID
    private static final String REF_REASON = "Dummy Reason"

    def "testing Reject Message BODY Serializing"() {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            SerializerContext context = SerializerContext.builder()
                .protocolBasicConfig(config.getBasicConfig())
                .build()
            RejectMsg rejectMessage = RejectMsg.builder()
                .message(VarStrMsg.builder().str(REF_MESSAGE).build())
                .ccode(REF_CCODE)
                .reason(VarStrMsg.builder().str(REF_REASON).build())
                .data(Utils.HEX.decode(REF_REJECT_BODY_HASH))
                .build()
            ByteArrayWriter byteWriter = new ByteArrayWriter()
            String messageSerialized = null
        when:
            RejectMsgSerializer.getInstance().serialize(context, rejectMessage, byteWriter)
            byte[] messageBytes = byteWriter.reader().getFullContent()
            byteWriter.reader()
            messageSerialized = Utils.HEX.encode(messageBytes)
        then:
            messageSerialized.equals(REF_REJECT_BODY_MSG)
    }

    def "testing Reject Message BODY De-Serializing"(int byteInterval, int delayMs) {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            DeserializerContext context = DeserializerContext.builder()
                    .protocolBasicConfig(config.getBasicConfig())
                    .maxBytesToRead((long) (REF_REJECT_BODY_MSG.length() / 2))
                    .build()
            RejectMsg rejectMsg = null
            ByteArrayReader byteReader = ByteArrayArtificalStreamProducer.stream(Utils.HEX.decode(REF_REJECT_BODY_MSG), byteInterval, delayMs)
        when:
            rejectMsg = RejectMsgSerializer.getInstance().deserialize(context, byteReader)
            Sha256Hash refHash = Sha256Hash.wrap(REF_REJECT_BODY_HASH)
            Sha256Hash msgHash = Sha256Hash.wrap(rejectMsg.getData());
        then:
            rejectMsg.getMessage().getStr().equals(REF_MESSAGE)
            rejectMsg.getCcode().equals(REF_CCODE)
            rejectMsg.getReason().getStr().equals(REF_REASON)
            refHash.equals(msgHash)
        where:
            byteInterval | delayMs
                10       |    25
    }

    def "testing Reject Message COMPLETE Serializing"() {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            SerializerContext context = SerializerContext.builder()
                    .protocolBasicConfig(config.getBasicConfig())
                    .build()
            RejectMsg rejectMsg = RejectMsg.builder()
                    .message(VarStrMsg.builder().str(REF_MESSAGE).build())
                    .ccode(REF_CCODE)
                    .reason(VarStrMsg.builder().str(REF_REASON).build())
                    .data(Utils.HEX.decode(REF_REJECT_BODY_HASH))
                    .build()
            BitcoinMsg<RejectMsg> rejectBitcoinMsg = new BitcoinMsgBuilder<>(config.getBasicConfig(), rejectMsg).build()
            BitcoinMsgSerializer serializer = BitcoinMsgSerializerImpl.getInstance()
        when:
            byte[] bytes = serializer.serialize(context, rejectBitcoinMsg).getFullContent()
            String rejectMsgSerialized = Utils.HEX.encode(bytes)
        then:
            rejectMsgSerialized.equals(REF_REJECT_MSG)
    }

    def "testing Reject Message COMPLETE De-serializing"(int byteInterval, int delayMs) {
        given:
            ProtocolConfig config = ProtocolConfigBuilder.get(new MainNetParams(Net.MAINNET))
            DeserializerContext context = DeserializerContext.builder()
                    .protocolBasicConfig(config.getBasicConfig())
                    .maxBytesToRead(Utils.HEX.decode(REF_REJECT_MSG).length)
                    .build()
            ByteArrayReader byteReader = ByteArrayArtificalStreamProducer.stream(Utils.HEX.decode(REF_REJECT_MSG), byteInterval, delayMs)
            BitcoinMsgSerializer bitcoinSerializer = BitcoinMsgSerializerImpl.getInstance()
        when:
            BitcoinMsg<RejectMsg> rejectBitcoinMsg = bitcoinSerializer.deserialize(context, byteReader)
            Sha256Hash refHash = Sha256Hash.wrap(REF_REJECT_BODY_HASH)
            Sha256Hash msgHash = Sha256Hash.wrap(rejectBitcoinMsg.getBody().getData())
        then:
            rejectBitcoinMsg.getHeader().getMagic().equals(config.getBasicConfig().getMagicPackage())
            rejectBitcoinMsg.getHeader().getCommand().equals(RejectMsg.MESSAGE_TYPE)
            rejectBitcoinMsg.getBody().getMessage().getStr().equals(REF_MESSAGE)
            rejectBitcoinMsg.getBody().getCcode().equals(REF_CCODE)
            rejectBitcoinMsg.getBody().getReason().getStr().equals(REF_REASON)
            refHash.equals(msgHash)
        where:
            byteInterval | delayMs
                10       |    25
    }
}
